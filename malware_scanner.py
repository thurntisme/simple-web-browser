"""
Malware Scanner Module
Provides comprehensive file scanning capabilities for malware detection.
"""

import os
import hashlib
import mimetypes
import threading
import time
import re
import zipfile
import tempfile
from datetime import datetime
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *


class MalwareScanner(QObject):
    """Main malware scanner class with multiple detection methods"""
    
    # Signals for progress updates
    scan_progress = pyqtSignal(int)  # Progress percentage
    scan_status = pyqtSignal(str)    # Status message
    scan_complete = pyqtSignal(dict) # Results dictionary
    
    def __init__(self):
        super().__init__()
        self.is_scanning = False
        self.should_stop = False
        
        # Known malware signatures (simplified examples)
        self.malware_signatures = {
            # EICAR test file - exact signature
            'eicar_test': b'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*',
            # Alternative EICAR format
            'eicar_alt': b'EICAR-STANDARD-ANTIVIRUS-TEST-FILE',
            'suspicious_vbs': b'WScript.Shell',
            'suspicious_js': b'eval(unescape(',
            'suspicious_powershell': b'powershell.exe -ExecutionPolicy Bypass',
            'suspicious_cmd': b'cmd.exe /c',
        }
        
        # Suspicious file extensions
        self.suspicious_extensions = {
            '.exe', '.scr', '.bat', '.cmd', '.com', '.pif', '.vbs', '.js', 
            '.jar', '.ps1', '.msi', '.dll', '.sys', '.drv'
        }
        
        # Known malicious hash database (MD5 hashes)
        self.malicious_hashes = {
            # EICAR test file hash (correct MD5)
            '44d88612fea8a8f36de82e1278abb02f': 'EICAR Test File',
            '68b329da9893e34099c7d8ad5cb9c940': 'EICAR Test File (alternative)',
            # Add more known malicious hashes here
        }
        
        # Suspicious patterns in file content
        self.suspicious_patterns = [
            rb'CreateObject\s*\(\s*["\']WScript\.Shell["\']',
            rb'CreateObject\s*\(\s*["\']Shell\.Application["\']',
            rb'powershell\.exe.*-EncodedCommand',
            rb'cmd\.exe.*\/c.*del.*\/q',
            rb'regsvr32.*\/s.*\/u.*scrobj\.dll',
            rb'bitsadmin.*\/transfer',
            rb'certutil.*-decode',
            rb'wmic.*process.*call.*create',
        ]

    def scan_file(self, file_path):
        """
        Comprehensive file scan using multiple detection methods
        
        Args:
            file_path (str): Path to the file to scan
            
        Returns:
            dict: Scan results with threat level and details
        """
        if not os.path.exists(file_path):
            return {'error': 'File not found', 'threat_level': 'unknown'}
        
        self.is_scanning = True
        self.should_stop = False
        
        results = {
            'file_path': file_path,
            'file_name': os.path.basename(file_path),
            'file_size': os.path.getsize(file_path),
            'scan_time': datetime.now().isoformat(),
            'threat_level': 'clean',
            'threats_found': [],
            'scan_methods': [],
            'file_info': {},
            'recommendations': []
        }
        
        try:
            # Get file information
            self.scan_status.emit("Analyzing file information...")
            self.scan_progress.emit(10)
            results['file_info'] = self._get_file_info(file_path)
            
            if self.should_stop:
                return results
            
            # Method 1: Extension-based analysis
            self.scan_status.emit("Checking file extension...")
            self.scan_progress.emit(20)
            ext_result = self._check_extension(file_path)
            if ext_result:
                results['threats_found'].append(ext_result)
                results['threat_level'] = 'suspicious'
            results['scan_methods'].append('Extension Analysis')
            
            if self.should_stop:
                return results
            
            # Method 2: Hash-based detection
            self.scan_status.emit("Computing file hash...")
            self.scan_progress.emit(30)
            hash_result = self._check_hash(file_path)
            if hash_result:
                results['threats_found'].append(hash_result)
                results['threat_level'] = 'malicious'
            results['scan_methods'].append('Hash Analysis')
            
            if self.should_stop:
                return results
            
            # Method 3: Signature-based detection
            self.scan_status.emit("Scanning for malware signatures...")
            self.scan_progress.emit(50)
            sig_results = self._signature_scan(file_path)
            if sig_results:
                results['threats_found'].extend(sig_results)
                results['threat_level'] = 'malicious'
            results['scan_methods'].append('Signature Scan')
            
            if self.should_stop:
                return results
            
            # Method 4: Heuristic analysis
            self.scan_status.emit("Performing heuristic analysis...")
            self.scan_progress.emit(70)
            heuristic_results = self._heuristic_analysis(file_path)
            if heuristic_results:
                results['threats_found'].extend(heuristic_results)
                if results['threat_level'] == 'clean':
                    results['threat_level'] = 'suspicious'
            results['scan_methods'].append('Heuristic Analysis')
            
            if self.should_stop:
                return results
            
            # Method 5: Archive scanning (if applicable)
            if self._is_archive(file_path):
                self.scan_status.emit("Scanning archive contents...")
                self.scan_progress.emit(85)
                archive_results = self._scan_archive(file_path)
                if archive_results:
                    results['threats_found'].extend(archive_results)
                    if results['threat_level'] == 'clean':
                        results['threat_level'] = 'suspicious'
                results['scan_methods'].append('Archive Scan')
            
            # Generate recommendations
            self.scan_status.emit("Generating recommendations...")
            self.scan_progress.emit(95)
            results['recommendations'] = self._generate_recommendations(results)
            
            self.scan_progress.emit(100)
            self.scan_status.emit("Scan complete")
            
        except Exception as e:
            results['error'] = str(e)
            results['threat_level'] = 'error'
        
        finally:
            self.is_scanning = False
        
        return results
    
    def stop_scan(self):
        """Stop the current scan"""
        self.should_stop = True
    
    def _get_file_info(self, file_path):
        """Get detailed file information"""
        stat = os.stat(file_path)
        mime_type, _ = mimetypes.guess_type(file_path)
        
        return {
            'size_bytes': stat.st_size,
            'size_human': self._format_bytes(stat.st_size),
            'created': datetime.fromtimestamp(stat.st_ctime).isoformat(),
            'modified': datetime.fromtimestamp(stat.st_mtime).isoformat(),
            'mime_type': mime_type or 'unknown',
            'extension': os.path.splitext(file_path)[1].lower(),
            'is_executable': os.access(file_path, os.X_OK),
        }
    
    def _check_extension(self, file_path):
        """Check if file extension is suspicious"""
        ext = os.path.splitext(file_path)[1].lower()
        if ext in self.suspicious_extensions:
            return {
                'type': 'suspicious_extension',
                'severity': 'medium',
                'description': f'Potentially dangerous file extension: {ext}',
                'details': f'Files with {ext} extension can execute code and may be malicious'
            }
        return None
    
    def _check_hash(self, file_path):
        """Check file hash against known malicious hashes"""
        try:
            with open(file_path, 'rb') as f:
                file_hash = hashlib.md5(f.read()).hexdigest()
            
            if file_hash in self.malicious_hashes:
                return {
                    'type': 'known_malware',
                    'severity': 'high',
                    'description': f'Known malware detected: {self.malicious_hashes[file_hash]}',
                    'details': f'File hash {file_hash} matches known malware signature',
                    'hash': file_hash
                }
        except Exception:
            pass
        return None
    
    def _signature_scan(self, file_path):
        """Scan file content for malware signatures"""
        threats = []
        try:
            with open(file_path, 'rb') as f:
                content = f.read(1024 * 1024)  # Read first 1MB
                
                for sig_name, signature in self.malware_signatures.items():
                    if signature in content:
                        threats.append({
                            'type': 'malware_signature',
                            'severity': 'high',
                            'description': f'Malware signature detected: {sig_name}',
                            'details': f'File contains known malicious pattern',
                            'signature': sig_name
                        })
        except Exception:
            pass
        return threats
    
    def _heuristic_analysis(self, file_path):
        """Perform heuristic analysis for suspicious patterns"""
        threats = []
        try:
            with open(file_path, 'rb') as f:
                content = f.read(1024 * 1024)  # Read first 1MB
                
                for pattern in self.suspicious_patterns:
                    if re.search(pattern, content, re.IGNORECASE):
                        threats.append({
                            'type': 'suspicious_pattern',
                            'severity': 'medium',
                            'description': 'Suspicious code pattern detected',
                            'details': 'File contains patterns commonly used by malware',
                            'pattern': pattern.decode('utf-8', errors='ignore')
                        })
        except Exception:
            pass
        return threats
    
    def _is_archive(self, file_path):
        """Check if file is an archive"""
        ext = os.path.splitext(file_path)[1].lower()
        return ext in ['.zip', '.rar', '.7z', '.tar', '.gz']
    
    def _scan_archive(self, file_path):
        """Scan contents of archive files"""
        threats = []
        try:
            if file_path.lower().endswith('.zip'):
                with zipfile.ZipFile(file_path, 'r') as zip_file:
                    for file_info in zip_file.filelist:
                        # Check for suspicious filenames in archive
                        if any(file_info.filename.lower().endswith(ext) for ext in self.suspicious_extensions):
                            threats.append({
                                'type': 'suspicious_archive_content',
                                'severity': 'medium',
                                'description': f'Suspicious file in archive: {file_info.filename}',
                                'details': 'Archive contains potentially dangerous files'
                            })
        except Exception:
            pass
        return threats
    
    def _generate_recommendations(self, results):
        """Generate security recommendations based on scan results"""
        recommendations = []
        
        if results['threat_level'] == 'malicious':
            recommendations.extend([
                "üö® DO NOT execute this file - it contains malware",
                "üóëÔ∏è Delete the file immediately",
                "üîç Run a full system scan with updated antivirus",
                "üîí Check if your system is already compromised"
            ])
        elif results['threat_level'] == 'suspicious':
            recommendations.extend([
                "‚ö†Ô∏è Exercise extreme caution with this file",
                "üîç Scan with multiple antivirus engines",
                "üè† Only run in isolated environment if necessary",
                "üìß Verify file source and authenticity"
            ])
        else:
            recommendations.extend([
                "‚úÖ File appears clean based on current analysis",
                "üîÑ Keep antivirus definitions updated",
                "üîç Consider additional scanning if suspicious behavior occurs"
            ])
        
        return recommendations
    
    def _format_bytes(self, bytes_size):
        """Format bytes to human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if bytes_size < 1024.0:
                return f"{bytes_size:.1f} {unit}"
            bytes_size /= 1024.0
        return f"{bytes_size:.1f} TB"


class MalwareScannerDialog(QDialog):
    """Dialog for displaying malware scan results"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.scanner = MalwareScanner()
        self.scan_thread = None
        self.setup_ui()
        self.connect_signals()
    
    def setup_ui(self):
        """Setup the user interface"""
        self.setWindowTitle("üõ°Ô∏è Malware Scanner")
        self.setMinimumSize(800, 600)
        self.setModal(True)
        
        layout = QVBoxLayout(self)
        
        # Header
        header_layout = QHBoxLayout()
        header_icon = QLabel("üõ°Ô∏è")
        header_icon.setStyleSheet("font-size: 24px;")
        header_title = QLabel("Malware Scanner")
        header_title.setStyleSheet("font-size: 18px; font-weight: bold; color: #2c3e50;")
        header_layout.addWidget(header_icon)
        header_layout.addWidget(header_title)
        header_layout.addStretch()
        layout.addLayout(header_layout)
        
        # File selection
        file_group = QGroupBox("üìÅ File Selection")
        file_layout = QVBoxLayout(file_group)
        
        file_select_layout = QHBoxLayout()
        self.file_path_edit = QLineEdit()
        self.file_path_edit.setPlaceholderText("Select a file to scan...")
        self.browse_btn = QPushButton("üìÇ Browse")
        self.browse_btn.clicked.connect(self.browse_file)
        file_select_layout.addWidget(self.file_path_edit)
        file_select_layout.addWidget(self.browse_btn)
        file_layout.addLayout(file_select_layout)
        
        layout.addWidget(file_group)
        
        # Scan controls
        controls_layout = QHBoxLayout()
        self.scan_btn = QPushButton("üîç Start Scan")
        self.scan_btn.clicked.connect(self.start_scan)
        self.stop_btn = QPushButton("‚èπÔ∏è Stop Scan")
        self.stop_btn.clicked.connect(self.stop_scan)
        self.stop_btn.setEnabled(False)
        controls_layout.addWidget(self.scan_btn)
        controls_layout.addWidget(self.stop_btn)
        controls_layout.addStretch()
        layout.addLayout(controls_layout)
        
        # Progress
        progress_group = QGroupBox("üìä Scan Progress")
        progress_layout = QVBoxLayout(progress_group)
        
        self.progress_bar = QProgressBar()
        self.status_label = QLabel("Ready to scan")
        progress_layout.addWidget(self.progress_bar)
        progress_layout.addWidget(self.status_label)
        
        layout.addWidget(progress_group)
        
        # Results
        results_group = QGroupBox("üìã Scan Results")
        results_layout = QVBoxLayout(results_group)
        
        # Results tabs
        self.results_tabs = QTabWidget()
        
        # Summary tab
        self.summary_tab = QWidget()
        summary_layout = QVBoxLayout(self.summary_tab)
        self.summary_text = QTextEdit()
        self.summary_text.setReadOnly(True)
        summary_layout.addWidget(self.summary_text)
        self.results_tabs.addTab(self.summary_tab, "üìä Summary")
        
        # Threats tab
        self.threats_tab = QWidget()
        threats_layout = QVBoxLayout(self.threats_tab)
        self.threats_list = QListWidget()
        threats_layout.addWidget(self.threats_list)
        self.results_tabs.addTab(self.threats_tab, "‚ö†Ô∏è Threats")
        
        # Details tab
        self.details_tab = QWidget()
        details_layout = QVBoxLayout(self.details_tab)
        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        details_layout.addWidget(self.details_text)
        self.results_tabs.addTab(self.details_tab, "üîç Details")
        
        results_layout.addWidget(self.results_tabs)
        layout.addWidget(results_group)
        
        # Action buttons
        button_layout = QHBoxLayout()
        self.export_btn = QPushButton("üíæ Export Results")
        self.export_btn.clicked.connect(self.export_results)
        self.export_btn.setEnabled(False)
        self.close_btn = QPushButton("‚ùå Close")
        self.close_btn.clicked.connect(self.close)
        button_layout.addWidget(self.export_btn)
        button_layout.addStretch()
        button_layout.addWidget(self.close_btn)
        layout.addLayout(button_layout)
        
        # Store results for export
        self.last_results = None
    
    def connect_signals(self):
        """Connect scanner signals"""
        self.scanner.scan_progress.connect(self.update_progress)
        self.scanner.scan_status.connect(self.update_status)
        self.scanner.scan_complete.connect(self.display_results)
    
    def browse_file(self):
        """Browse for file to scan"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select File to Scan",
            "",
            "All Files (*.*)"
        )
        if file_path:
            self.file_path_edit.setText(file_path)
    
    def start_scan(self):
        """Start malware scan"""
        file_path = self.file_path_edit.text().strip()
        if not file_path:
            QMessageBox.warning(self, "Warning", "Please select a file to scan.")
            return
        
        if not os.path.exists(file_path):
            QMessageBox.warning(self, "Warning", "Selected file does not exist.")
            return
        
        # Reset UI
        self.progress_bar.setValue(0)
        self.status_label.setText("Starting scan...")
        self.scan_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        self.export_btn.setEnabled(False)
        
        # Clear previous results
        self.summary_text.clear()
        self.threats_list.clear()
        self.details_text.clear()
        
        # Start scan in thread
        self.scan_thread = threading.Thread(
            target=lambda: self.scanner.scan_complete.emit(self.scanner.scan_file(file_path))
        )
        self.scan_thread.daemon = True
        self.scan_thread.start()
    
    def stop_scan(self):
        """Stop current scan"""
        self.scanner.stop_scan()
        self.scan_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.status_label.setText("Scan stopped by user")
    
    def update_progress(self, value):
        """Update progress bar"""
        self.progress_bar.setValue(value)
    
    def update_status(self, message):
        """Update status label"""
        self.status_label.setText(message)
    
    def display_results(self, results):
        """Display scan results"""
        self.last_results = results
        self.scan_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.export_btn.setEnabled(True)
        
        # Display summary
        self.display_summary(results)
        
        # Display threats
        self.display_threats(results)
        
        # Display details
        self.display_details(results)
        
        # Set appropriate tab based on results
        if results.get('threats_found'):
            self.results_tabs.setCurrentIndex(1)  # Threats tab
        else:
            self.results_tabs.setCurrentIndex(0)  # Summary tab
    
    def display_summary(self, results):
        """Display summary in summary tab"""
        threat_level = results.get('threat_level', 'unknown')
        threats_count = len(results.get('threats_found', []))
        
        # Determine status color and icon
        if threat_level == 'malicious':
            status_color = "#e74c3c"
            status_icon = "üö®"
            status_text = "MALICIOUS"
        elif threat_level == 'suspicious':
            status_color = "#f39c12"
            status_icon = "‚ö†Ô∏è"
            status_text = "SUSPICIOUS"
        elif threat_level == 'clean':
            status_color = "#27ae60"
            status_icon = "‚úÖ"
            status_text = "CLEAN"
        else:
            status_color = "#95a5a6"
            status_icon = "‚ùì"
            status_text = "UNKNOWN"
        
        summary_html = f"""
        <div style="font-family: Arial, sans-serif; padding: 10px;">
            <h2 style="color: {status_color};">{status_icon} Scan Result: {status_text}</h2>
            
            <h3>üìÅ File Information</h3>
            <table style="border-collapse: collapse; width: 100%;">
                <tr><td><b>File Name:</b></td><td>{results.get('file_name', 'N/A')}</td></tr>
                <tr><td><b>File Path:</b></td><td>{results.get('file_path', 'N/A')}</td></tr>
                <tr><td><b>File Size:</b></td><td>{results.get('file_info', {}).get('size_human', 'N/A')}</td></tr>
                <tr><td><b>File Type:</b></td><td>{results.get('file_info', {}).get('mime_type', 'N/A')}</td></tr>
                <tr><td><b>Extension:</b></td><td>{results.get('file_info', {}).get('extension', 'N/A')}</td></tr>
            </table>
            
            <h3>üîç Scan Information</h3>
            <table style="border-collapse: collapse; width: 100%;">
                <tr><td><b>Scan Time:</b></td><td>{results.get('scan_time', 'N/A')}</td></tr>
                <tr><td><b>Threats Found:</b></td><td>{threats_count}</td></tr>
                <tr><td><b>Scan Methods:</b></td><td>{', '.join(results.get('scan_methods', []))}</td></tr>
            </table>
            
            <h3>üí° Recommendations</h3>
            <ul>
        """
        
        for rec in results.get('recommendations', []):
            summary_html += f"<li>{rec}</li>"
        
        summary_html += "</ul></div>"
        
        self.summary_text.setHtml(summary_html)
    
    def display_threats(self, results):
        """Display threats in threats tab"""
        self.threats_list.clear()
        
        for threat in results.get('threats_found', []):
            severity = threat.get('severity', 'unknown')
            description = threat.get('description', 'Unknown threat')
            
            # Create list item
            item = QListWidgetItem()
            
            # Set icon based on severity
            if severity == 'high':
                icon_text = "üö®"
                color = "#e74c3c"
            elif severity == 'medium':
                icon_text = "‚ö†Ô∏è"
                color = "#f39c12"
            else:
                icon_text = "‚ÑπÔ∏è"
                color = "#3498db"
            
            item.setText(f"{icon_text} {description}")
            item.setData(Qt.UserRole, threat)  # Store full threat data
            
            # Set text color
            item.setForeground(QColor(color))
            
            self.threats_list.addItem(item)
        
        if not results.get('threats_found'):
            item = QListWidgetItem("‚úÖ No threats detected")
            item.setForeground(QColor("#27ae60"))
            self.threats_list.addItem(item)
    
    def display_details(self, results):
        """Display detailed results in details tab"""
        import json
        
        # Format results as JSON for detailed view
        details_json = json.dumps(results, indent=2, default=str)
        self.details_text.setPlainText(details_json)
    
    def export_results(self):
        """Export scan results to file"""
        if not self.last_results:
            return
        
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Scan Results",
            f"malware_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
            "JSON Files (*.json);;Text Files (*.txt);;All Files (*.*)"
        )
        
        if file_path:
            try:
                import json
                with open(file_path, 'w') as f:
                    json.dump(self.last_results, f, indent=2, default=str)
                
                QMessageBox.information(
                    self,
                    "Export Successful",
                    f"Scan results exported to:\n{file_path}"
                )
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Export Failed",
                    f"Failed to export results:\n{str(e)}"
                )


def show_malware_scanner(parent=None, file_path=None):
    """Show malware scanner dialog"""
    dialog = MalwareScannerDialog(parent)
    
    if file_path:
        dialog.file_path_edit.setText(file_path)
    
    dialog.exec_()
    return dialog


if __name__ == "__main__":
    # Test the malware scanner
    import sys
    from PyQt5.QtWidgets import QApplication
    
    app = QApplication(sys.argv)
    dialog = MalwareScannerDialog()
    dialog.show()
    sys.exit(app.exec_())